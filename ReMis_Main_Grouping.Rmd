---
title: "ReMis Main Grouping"
author: "Marton Kovacs"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
---

# Load packages

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(writexl)
library(readxl)
library(qdap)
library(DiagrammeR) # For the flowchart
library(grid) # For the flowchart
library(Gmisc) # For the flowchart
```

# Load helper functions

```{r}
source("utils.R")
```

# Reading in processed data

```{r}
processed <- read_tsv("Processed/ReMis_Main_Processed_data.tsv")
```

# Thematic grouping

The thematic grouping methodology is applied to the descriptions of **mistakes**, **causes** and **outcomes** separately.

## Response separation

Some respondents wrote more than one answer to a given question. In order not to lose any information the authors read through the responses and separate the responses if they contain multiple responses.

Since we asked the respondents to describe their teams most **recurring** and most **serious** mistakes, and their causes and their outcomes we have to treat these differently later on. We keep this information in the variable named "[mistake or cause or ourcome]_tpye".

We keep the original response in the variable named "mistake" and "cause" and "outcome". During the separation this variable will not be touched.

The separated answers will be kept in new variables with and increasing id number in their name.

E.g. If there are two answers in one response in "mistake" then those two answers will bea separated in the "mistake_1" and "mistake_2" variables.

### Data management mistakes
#### Number of responses before separation

For counting the response before the separation we do not include the missing responses.

```{r}
processed %>% 
  transmute(response_id,
            recurring_story,
            serious_story) %>% 
  gather(key = "mistake_type", value = "mistake", -response_id) %>% 
  mutate(mistake_type = str_extract(mistake_type, "[^_]+")) %>% 
  drop_na(mistake) %>% 
  count()
```

#### Transforming data

```{r}
processed %>%
  transmute(response_id,
            recurring_story,
            serious_story) %>% 
  gather(key = "mistake_type", value = "mistake", -response_id) %>% 
  mutate(mistake_type = str_extract(mistake_type, "[^_]+"),
         mistake_1 = NA_character_,
         mistake_2 = NA_character_) %>% 
  head() %>%
  knitr::kable() 
 # write_xlsx(., "Processed/grouping/separation/ReMis_Main_Processed_Mistake_data.xlsx")
```

### Causes of mistakes
#### Number of responses before separation

For counting the response before the separation we do not include the missing responses.

```{r}
processed %>% 
  transmute(response_id,
            recurring_cause,
            serious_cause) %>% 
  gather(key = "cause_type", value = "cause", -response_id) %>% 
  mutate(cause_type = str_extract(cause_type, "[^_]+")) %>% 
  drop_na(cause) %>% 
  count()
```

#### Transforming data

```{r}
processed %>% 
  transmute(response_id,
            recurring_cause,
            serious_cause) %>% 
  gather(key = "cause_type", value = "cause", -response_id) %>% 
  mutate(cause_type = str_extract(cause_type, "[^_]+"),
         cause_1 = NA_character_,
         cause_2 = NA_character_) %>% 
  head() %>% 
  knitr::kable()
  #write_xlsx(., "Processed/grouping/separation/ReMis_Main_Processed_Cause_data.xlsx")
```

### Outcomes of mistakes
#### Number of responses before separation

For counting the response before the separation we do not include the missing responses.

```{r}
processed %>% 
  transmute(response_id,
            recurring_outcome,
            serious_outcome) %>% 
  gather(key = "outcome_type", value = "outcome", -response_id) %>% 
  mutate(outcome_type = str_extract(outcome_type, "[^_]+")) %>% 
  drop_na(outcome) %>% 
  count()
```

#### Transforming data

```{r}
processed %>% 
  transmute(response_id,
            recurring_outcome,
            serious_outcome) %>% 
  gather(key = "outcome_type", value = "outcome", -response_id) %>% 
  mutate(outcome_type = str_extract(outcome_type, "[^_]+"),
         outcome_1 = NA_character_) %>% 
  head() %>% 
  knitr::kable()
 # write_xlsx(., "Processed/grouping/separation/ReMis_Main_Processed_Outcome_data.xlsx")
```

## Creating codes 

First, we read the output of the separation process of the mistakes, causes and outcomes.

Second, we transform the data to prepare them for the coding of the separated responses.

Third, we save the transformed datatable.

### Data management mistake types
#### Read data

```{r}
processed_mistake_data <- read_xlsx("Processed/grouping/separation/ReMis_Main_Processed_Mistake_data.xlsx")
```

#### Transform data

```{r}
processed_mistake_data <-
  processed_mistake_data %>% 
  gather(key = "mistake_no", value = "mistake_sep", -response_id, -mistake_type, -mistake) %>%
  mutate(mistake_no = str_extract(mistake_no, "[0-9]$"),
         mistake_no = as.integer(mistake_no),
         code = NA_character_) %>% 
  drop_na(mistake_sep)
```

#### Number of responses after separation

```{r}
processed_mistake_data  %>% 
  drop_na(mistake) %>% 
  count()
```

```{r}
processed_mistake_data %>% 
  filter(mistake_no > 1) %>% 
  distinct(response_id) %>% 
  count()
```
#### Write data

```{r}
# write_xlsx(processed_mistake_data, "Processed/ReMis_Main_Processed_Mistake_Type_Coding_data.xlsx")
```

### Causes of mistakes
#### Read data

```{r}
processed_cause_data <- read_xlsx("Processed/grouping/separation/ReMis_Main_Processed_Cause_data.xlsx")
```

#### Transform data

```{r}
processed_cause_data <-
  processed_cause_data %>% 
  gather(key = "cause_no", value = "cause_sep", -response_id, -cause_type, -cause) %>%
  mutate(cause_no = str_extract(cause_no, "[0-9]$"),
         cause_no = as.integer(cause_no),
         code = NA_character_) %>% 
  drop_na(cause_sep)
```

#### Number of responses after separation

```{r}
processed_cause_data  %>% 
  drop_na(cause) %>% 
  count()
```

#### Write data

```{r}
# write_xlsx(processed_cause_data, "Processed/ReMis_Main_Processed_Cause_Coding_data.xlsx")
```

### Outcomes of mistakes
#### Read data

```{r}
processed_outcome_data <- read_xlsx("Processed/grouping/separation/ReMis_Main_Processed_Outcome_data.xlsx")
```

#### Transform data

```{r}
processed_outcome_data <- 
  processed_outcome_data %>% 
  gather(key = "outcome_no", value = "outcome_sep", -response_id, -outcome_type, -outcome) %>%
  mutate(outcome_no = str_extract(outcome_no, "[0-9]$"),
         outcome_no = as.integer(outcome_no),
         code = NA_character_) %>% 
  drop_na(outcome_sep)
```

#### Number of responses after separation

```{r}
processed_outcome_data  %>% 
  drop_na(outcome) %>% 
  count()
```

#### Write data

```{r}
# write_xlsx(processed_outcome_data, "Processed/ReMis_Main_Processed_Outcome_Coding_data.xlsx")
```

## Defining groups

First, we read the output of the coding process of the separated mistakes, causes and outcomes.

Second, we transform the codes to use them for creating the groups.

Third, we save the transformed datatable.

### Data management mistake types
#### Read data

```{r}
processed_mistake_type_coding <-
  read_xlsx("Processed/grouping/coding/ReMis_Main_Processed_Mistake_Type_Coding_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))
```

#### Counting the number of excluded responses

After the response separation we excluded cases if: (1) the participant’s response was irrelevant to the question, or missing; or (2) stated that the mistake occurred before the prescribed timeframe (i.e., past 5 years).

##### Number of exluded responses

```{r}
processed_mistake_type_coding %>% 
  filter(code %in% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  group_by(code) %>% 
  count() %>% 
  ungroup() %>% 
  mutate(sum_n = sum(n))
```

##### Number of responses after exclusion

```{r}
processed_mistake_type_coding %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  count()
```

##### Number of responses excluded because of insufficient information

```{r}
processed_mistake_type_coding %>% 
  filter(code == "insufficient information") %>% 
  count()
```

##### Number of responses after exclusion because of insufficient information

```{r}
processed_mistake_type_coding %>% 
  filter(code != "insufficient information") %>% 
  count()
```

#### Transform data

```{r}
processed_mistake_type_coding_count <-
  processed_mistake_type_coding %>% 
  group_by(code) %>%
  count() %>% 
  mutate(group = NA_character_) %>%
  arrange(code)
```

#### Counting the number of disctinct codes

```{r}
processed_mistake_type_coding_count %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe",
                     "insufficient information")) %>% 
  ungroup() %>% 
  count()
```

#### Write data

```{r}
# write_xlsx(processed_mistake_type_coding_count, "Processed/ReMis_Main_Processed_Mistake_Type_Grouping.xlsx")
```

#### Testing similarity between tables

The tables are handled in a spreadsheet therefore it is possible that there are dissimilarities between them. Therefore, these test compare the parts of the tables that should be similar.

```{r}
setdiff(
  select(processed_mistake_type_coding, -code),
  select(processed_mistake_data, -code)
  )
```

### Causes of mistakes
#### Read data

```{r}
processed_cause_coding <-
  read_xlsx("Processed/grouping/coding/ReMis_Main_Processed_Cause_Coding_data.xlsx") %>% 
  mutate(cause_no = as.integer(cause_no))
```

#### Counting the number of excluded responses

After the response separation we excluded cases if: (1) the participant’s response was irrelevant to the question, or missing; or (2) stated that the mistake occurred before the prescribed timeframe (i.e., past 5 years).

##### Number of exluded responses

```{r}
processed_cause_coding %>% 
  filter(code %in% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  group_by(code) %>% 
  count() %>% 
  mutate(sum_n = sum(n))
```

##### Number of responses after exclusion

```{r}
processed_cause_coding %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  count()
```

##### Number of responses excluded because of insufficient information

```{r}
processed_cause_coding %>% 
  filter(code == "insufficient information") %>% 
  count()
```

##### Number of responses after exclusion because of insufficient information

```{r}
processed_cause_coding %>% 
  filter(code != "insufficient information") %>% 
  count()
```

#### Transform data

```{r}
processed_cause_coding_count <-
  processed_cause_coding %>% 
  group_by(code) %>%
  count() %>%
  mutate(group = NA_character_) %>% 
  arrange(code)
```

#### Counting the number of disctinct codes

```{r}
processed_cause_coding_count %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe",
                     "insufficient information")) %>% 
  ungroup() %>% 
  count()
```

#### Write data

```{r}
# write_xlsx(processed_cause_coding_count, "Processed/ReMis_Main_Processed_Cause_Grouping.xlsx")
```

#### Testing similarity between tables

```{r}
setdiff(
  select(processed_cause_coding, -code),
  select(processed_cause_data, -code)
  )
```

### Outcomes of mistakes
#### Read data

```{r}
processed_outcome_coding <-
  read_xlsx("Processed/grouping/coding/ReMis_Main_Processed_Outcome_Coding_data.xlsx") %>% 
  mutate(outcome_no = as.integer(outcome_no))
```

#### Counting the number of excluded responses

After the response separation we excluded cases if: (1) the participant’s response was irrelevant to the question, or missing; or (2) stated that the mistake occurred before the prescribed timeframe (i.e., past 5 years).

##### Number of exluded responses

```{r}
processed_outcome_coding %>% 
  filter(code %in% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  group_by(code) %>% 
  count() %>% 
  mutate(sum_n = sum(n))
```

##### Number of responses after exclusion

```{r}
processed_outcome_coding %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe")) %>% 
  count()
```

##### Number of responses excluded because of insufficient information

```{r}
processed_outcome_coding %>% 
  filter(code == "insufficient information") %>% 
  count()
```

##### Number of responses after exclusion because of insufficient information

```{r}
processed_outcome_coding %>% 
  filter(code != "insufficient information") %>% 
  count()
```

#### Transform data

```{r}
processed_outcome_coding_count <-
  processed_outcome_coding %>% 
  group_by(code) %>%
  count() %>%
  mutate(group = NA_character_) %>% 
  arrange(code)
```

#### Counting the number of disctinct codes

```{r}
processed_outcome_coding_count %>% 
  filter(code %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe",
                     "insufficient information")) %>% 
  ungroup() %>% 
  count()
```

#### Write data

```{r}
# write_xlsx(processed_outcome_coding_count, "Processed/ReMis_Main_Processed_Outcome_Grouping.xlsx")
```

#### Testing similarity between tables

```{r}
setdiff(
  select(processed_outcome_coding, -code),
  select(processed_outcome_data, -code)
  )
```

Fourth, we read the output of the creating groups process, and enumerate all the codes that belong to a group to create a definition for the given group.

### Data management mistake types
#### Read data

```{r}
processed_mistake_type_grouping <- read_xlsx("Processed/grouping/group/ReMis_Main_Processed_Mistake_Type_Grouping.xlsx")
```

#### Count the number of codes that were not assigned to groups

```{r}
processed_mistake_type_grouping %>% 
  filter(group == "NA") %>% 
  count()
```

#### Transform data

```{r}
processed_mistake_type_definition <-
  processed_mistake_type_grouping %>% 
  filter(group %ni% c("see above",
                      "missing",
                      "irrelevant content",
                      "out of timeframe",
                      "insufficient information",
                      "NA")) %>%
  group_by(group) %>% 
  summarise(definition = str_c(code, collapse = "; ")) %>% 
  mutate(definition = tolower(definition))
```

#### Write data

```{r}
# write_xlsx(processed_mistake_type_definition, "Processed/definition/ReMis_Main_Processed_Mistake_Type_Definition.xlsx")
```

#### Testing
##### Testing similarity between tables

```{r}
setdiff(
  select(processed_mistake_type_coding_count, -group),
  select(processed_mistake_type_grouping, -group)
  )
```

##### Test if the sum of the number of codes equals the length of the responses

```{r}
processed_mistake_type_grouping %>% 
  summarise(sum_n = sum(n))

processed_mistake_type_coding %>% 
  count()
```

### Causes of mistakes
#### Read data

```{r}
processed_cause_grouping <- read_xlsx("Processed/grouping/group/ReMis_Main_Processed_Cause_Grouping.xlsx")
```

#### Count the number of codes that were not assigned to groups

```{r}
processed_cause_grouping %>% 
  filter(group == "NA") %>% 
  count()
```

#### Transform data

```{r}
processed_cause_definition <-
  processed_cause_grouping %>% 
  filter(group %ni% c("see above",
                      "missing",
                      "irrelevant content",
                      "out of timeframe",
                      "insufficient information",
                      "NA")) %>%
  group_by(group) %>% 
  summarise(definition = str_c(code, collapse = "; ")) %>% 
  mutate(definition = tolower(definition))
```

#### Write data

```{r}
# write_xlsx(processed_cause_definition, "Processed/definition/ReMis_Main_Processed_Cause_Definition.xlsx")
```

#### Testing
##### Testing similarity between tables

```{r}
setdiff(
  select(processed_cause_coding_count, -group),
  select(processed_casuse_grouping, -group)
)
```

##### Test if the sum of the number of codes equals the length of the responses

```{r}
processed_cause_grouping %>% 
  summarise(sum_n = sum(n))

processed_cause_coding %>% 
  count()
```

### Outcomes of mistakes
#### Read data

```{r}
processed_outcome_grouping <- read_xlsx("Processed/grouping/group/ReMis_Main_Processed_Outcome_Grouping.xlsx")
```

#### Count the number of codes that were not assigned to groups

```{r}
processed_outcome_grouping %>% 
  filter(group == "NA") %>% 
  count()
```

#### Transform data

```{r}
processed_outcome_definition <-
  processed_outcome_grouping %>% 
  filter(group %ni% c("see above",
                      "missing",
                      "irrelevant content",
                      "out of timeframe",
                      "insufficient information",
                      "NA")) %>%
  group_by(group) %>% 
  summarise(definition = str_c(code, collapse = "; ")) %>% 
  mutate(definition = tolower(definition))
```

#### Write data

```{r}
# write_xlsx(processed_outcome_definition, "Processed/definition/ReMis_Main_Processed_Outcome_Definition.xlsx")
```

#### Testing
##### Testing similarity between tables

```{r}
setdiff(
  select(processed_outcome_coding_count, -group),
  select(processed_outcome_grouping, -group)
)
```

##### Test if the sum of the number of codes equals the length of the responses

```{r}
processed_outcome_grouping %>% 
  summarise(sum_n = sum(n))

processed_outcome_coding %>% 
  count()
```

## Exclusion

First, we join the outputs of the creating codes and the defining groups processes.

Second, we exclude all the separated responses, where
* the corresponding code was not assigned to a group during the defining groups process ("NA")
* the respondent did not write down the response but refered to a previous response ("see above")
* the response was irrelevant to the given question ("irrelevant content")
* the response did not provide enough information to decide what did the respondent mean ("insufficient information")
* if the respondent expliciltly claimed the the mistake happen more then 5 years ago ("out of timeframe")
* if the response was missing ("missing")

### Data management mistake types
#### Merge each case with their group based on the codes

```{r}
processed_mistake_type_filtered <-
  processed_mistake_type_coding %>% 
  left_join(., processed_mistake_type_grouping, by = "code")
```

#### Count the number of responses that we exclude because we could not assign the code to a group

```{r}
processed_mistake_type_filtered %>% 
  filter(group == "NA") %>% 
  count()
```

#### Test if there is any case thats code is not grouped

```{r}
processed_mistake_type_filtered %>% 
  filter(is.na(group)) %>% 
  count()
```

#### Exclude cases based on ambiguous groups

```{r}
processed_mistake_type_filtered <-
  processed_mistake_type_filtered %>% 
  filter(group %ni% c("see above",
                     "missing",
                     "irrelevant content",
                     "out of timeframe",
                     "insufficient information",
                     "NA")) %>%
  select(-code, -n, -group)
```

### Causes of mistakes
#### Merge each case with their group based on the codes

```{r}
processed_cause_filtered <-
  processed_cause_coding %>% 
  left_join(., processed_cause_grouping, by = "code")
```

#### Count the number of responses that we exclude because we could not assign the code to a group

```{r}
processed_cause_filtered %>% 
  filter(group == "NA") %>% 
  count()
```

#### Test if there is any case thats code is not grouped

```{r}
processed_cause_filtered %>% 
  filter(is.na(group)) %>% 
  count()
```

# Exclude cases based on ambiguous groups

```{r}
processed_cause_filtered <-
  processed_cause_filtered %>% 
  filter(group %ni% c("see above",
                      "missing",
                      "irrelevant content",
                      "out of timeframe",
                      "insufficient information",
                      "NA")) %>%
  select(-code, -n, -group)
```

### Outcomes of mistakes
#### Merge each case with their group based on the codes

```{r}
processed_outcome_filtered <- 
  processed_outcome_coding %>% 
  left_join(., processed_outcome_grouping, by = "code")
```

#### Count the number of responses that we exclude because we could not assign the code to a group

```{r}
processed_outcome_filtered %>% 
  filter(group == "NA") %>% 
  count()
```

#### Test if there is any case thats code is not grouped

```{r}
processed_outcome_filtered %>% 
  filter(is.na(group)) %>% 
  count()
```

#### Exclude cases based on ambiguous groups

```{r}
processed_outcome_filtered <-
  processed_outcome_filtered %>% 
  filter(group %ni% c("see above",
                      "missing",
                      "irrelevant content",
                      "out of timeframe",
                      "insufficient information",
                      "NA")) %>%
  select(-code, -n, -group)
```

## Sorting the responses to groups
### Creating spreadsheets for the raters

Because sorting the separated responses to groups by independent raters require different amount of work for the different type of questions we divided the mistake types in half and sent it out to 4 independent raters.

#### Data management mistake types

```{r}
# Rater1
## Transform data
processed_mistake_type_rater1 <-
  processed_mistake_type_filtered %>% 
  mutate(group_rater1 = NA_character_) %>% 
  slice(1:599)

## Write data
# write_xlsx(processed_mistake_type_rater1, "Processed/grouping/rating/ReMis_Main_Processed_Type_Rater1_data.xlsx")

# Rater2
## Transform data
processed_mistake_type_rater2 <-
  processed_mistake_type_filtered %>% 
  mutate(group_rater2 = NA_character_) %>% 
  slice(1:599)

## Write data
# write_xlsx(processed_mistake_type_rater2, "Processed/grouping/rating/ReMis_Main_Processed_Type_test_data.xlsx")

# Rater3
## Transform data
processed_mistake_type_rater3 <-
  processed_mistake_type_filtered %>% 
  mutate(group_rater3 = NA_character_) %>%
  slice(600:786)

## Write data
# write_xlsx(processed_mistake_type_rater3, "Processed/rating/ReMis_Main_Processed_Type_Rater3_data.xlsx")

# Rater4
## Transform data
processed_mistake_type_rater4 <-
  processed_mistake_type_filtered %>% 
  mutate(group_rater4 = NA_character_) %>% 
  slice(600:786)

## Write data
# write_xlsx(processed_mistake_type_rater4, "Processed/grouping/rating/ReMis_Main_Processed_Type_Rater4_data.xlsx")
```

#### Causes of mistakes

```{r}
# Rater1
## Transform data
processed_cause_rater1 <-
  processed_cause_filtered %>% 
  mutate(group_rater1 = NA_character_)

## Write data
# write_xlsx(processed_cause_rater1, "Processed/grouping/rating/ReMis_Main_Processed_Cause_Rater1_data.xlsx")

# Rater2
## Transform data
processed_cause_rater2 <-
  processed_cause_filtered %>% 
  mutate(group_rater2 = NA_character_)

## Write data
# write_xlsx(processed_cause_rater2, "Processed/grouping/rating/ReMis_Main_Processed_Cause_Rater2_data.xlsx")
```

#### Outcomes of mistakes

```{r}
# Rater1
## Transform data
processed_outcome_rater1 <-
  processed_outcome_filtered %>% 
  mutate(group_rater1 = NA_character_) 

## Write data
# write_xlsx(processed_outcome_rater1, "Processed/grouping/rating/ReMis_Main_Processed_Outcome_Rater1_data.xlsx")

# Rater2
## Transform data
processed_outcome_rater2 <-
  processed_outcome_filtered %>% 
  mutate(group_rater2 = NA_character_)

## Write data
# write_xlsx(processed_outcome_rater2, "Processed/grouping/rating/ReMis_Main_Processed_Outcome_Rater2_data.xlsx")
```

### Sorting the responses to groups

The indepedent raters ratings were compared. In case of non-match, the raters could discuss the case. If they could not reach agreement, one of the authors made the final decision.

#### Data management mistake types
##### Read data

Read the datatables with the ratings of the independent raters.

```{r}
# Rater 1
processed_grouping_type_rater1 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Type_Rater1_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))

# Rater 2
processed_grouping_type_rater2 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Type_Rater2_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))

# Rater 3
processed_grouping_type_rater3 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Type_Rater3_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))

# Rater 4
processed_grouping_type_rater4 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Type_Rater4_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))
```

##### Test whether rated tables are similar to the prepared tables

During the rating process the independent raters could change other field than the required. To catch these cases we compare the tables that contain the rating with the ones that were prepared for the rating.

```{r}
# Rater 1
setdiff(
  select(processed_mistake_type_rater1, -group_rater1),
  select(processed_grouping_type_rater1, -group_rater1)
  )

# Rater 2
setdiff(
  select(processed_mistake_type_rater2, -group_rater2),
  select(processed_grouping_type_rater2, -group_rater2)
  )

# Rater 3
setdiff(
  select(processed_mistake_type_rater3, -group_rater3),
  select(processed_grouping_type_rater3, -group_rater3)
  ) 

# Rater 4
setdiff(
  select(processed_mistake_type_rater4, -group_rater4),
  select(processed_grouping_type_rater4, -group_rater4)
  )
```

##### Merging rated dataframes by corresponding raters

```{r}
processed_grouping_type_1 <- 
  left_join(processed_grouping_type_rater1, processed_grouping_type_rater2, by = c("response_id", "mistake_type", "mistake", "mistake_no", "mistake_sep"))

processed_grouping_type_2 <- 
  left_join(processed_grouping_type_rater3, processed_grouping_type_rater4, by = c("response_id", "mistake_type", "mistake", "mistake_no", "mistake_sep"))
```

##### Matching ratings

```{r}
processed_grouping_type_match_1 <- 
  processed_grouping_type_1 %>% 
  mutate(match = case_when(group_rater1 == group_rater2 ~ 1L,
                           group_rater1 != group_rater2 ~ 0L,
                           is.na(group_rater1) | is.na(group_rater2) ~ 0L),
         group_final = NA_character_)

processed_grouping_type_match_2 <- 
  processed_grouping_type_2 %>% 
  mutate(match = case_when(group_rater3 == group_rater4 ~ 1L,
                           group_rater3 != group_rater4 ~ 0L,
                           is.na(group_rater3) | is.na(group_rater4) ~ 0L),
         group_final = NA_character_)
```

##### Counting the number of matches and non matches before discussion

```{r}
processed_grouping_type_match_1 %>% 
  group_by(match) %>% 
  summarise(N = n()) %>% 
  mutate(sum_n = sum(N),
         freq = N / sum_n * 100)

processed_grouping_type_match_2 %>% 
  group_by(match) %>% 
  summarise(N = n()) %>% 
  mutate(sum_n = sum(N),
         freq = N / sum_n * 100)
```

##### Write matching rating results for discussion

```{r}
# write_xlsx(processed_grouping_type_match_1, "Processed/ReMis_Main_Processed_Grouping_Type_Match_1_data.xlsx")

# write_xlsx(processed_grouping_type_match_2, "Processed/ReMis_Main_Processed_Grouping_Type_Match_2_data.xlsx")
```

#### Causes of mistakes
##### Read data

```{r}
# Rater 1
processed_grouping_cause_rater1 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Cause_Rater1_data.xlsx") %>% 
  mutate(cause_no = as.integer(cause_no))

# Rater 2
processed_grouping_cause_rater2 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Cause_Rater2_data.xlsx") %>% 
  mutate(cause_no = as.integer(cause_no))
```

##### Test whether rated tables are similar to the prepared tables

```{r}
# Rater 1
setdiff(
  select(processed_cause_rater1, -group_rater1),
  select(processed_grouping_cause_rater1, -group_rater1)
)

# Rater 2
setdiff(
  select(processed_cause_rater2, -group_rater2),
  select(processed_grouping_cause_rater2, -group_rater2)
)
```

##### Merging rated dataframes by corresponding raters

```{r}
processed_grouping_cause <- 
  left_join(processed_grouping_cause_rater1, processed_grouping_cause_rater2, by = c("response_id", "cause_type", "cause", "cause_no", "cause_sep"))
```

##### Matching ratings

```{r}
processed_grouping_cause_match <- 
  processed_grouping_cause %>% 
  mutate(match = case_when(group_rater1 == group_rater2 ~ 1L,
                           group_rater1 != group_rater2 ~ 0L,
                           is.na(group_rater1) | is.na(group_rater2) ~ 0L),
         group_final = NA_character_)
```

##### Counting the number of matches and non matches before discussion

```{r}
processed_grouping_cause_match %>% 
  group_by(match) %>% 
  summarise(N = n()) %>% 
  mutate(sum_n = sum(N),
         freq = N / sum_n * 100)
```

##### Write matching rating results for discussion

```{r}
# write_xlsx(processed_grouping_cause_match, "Processed/ReMis_Main_Processed_Grouping_Cause_Match_data.xlsx")
```

#### Outcomes of mistakes
##### Read data

```{r}
## Rater 1
processed_grouping_outcome_rater1 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Outcome_Rater1_data.xlsx") %>% 
  mutate(outcome_no = as.integer(outcome_no))

## Rater 2
processed_grouping_outcome_rater2 <-
  read_xlsx("Processed/grouping/rated/ReMis_Main_Processed_Outcome_Rater2_data.xlsx") %>% 
  mutate(outcome_no = as.integer(outcome_no))
```

##### Test whether rated tables are similar to the prepared tables

```{r}
# Rater 1
setdiff(
  select(processed_outcome_rater1, -group_rater1),
  select(processed_grouping_outcome_rater1, -group_rater1)
)

# Rater 2
setdiff(
  select(processed_outcome_rater2, -group_rater2),
  select(processed_grouping_outcome_rater2, -group_rater2)
)
```

##### Merging rated dataframes by corresponding raters

```{r}
processed_grouping_outcome <- 
  left_join(processed_grouping_outcome_rater1, processed_grouping_outcome_rater2, by = c("response_id", "outcome_type", "outcome", "outcome_no", "outcome_sep"))
```

##### Matching ratings

```{r}
processed_grouping_outcome_match <- 
  processed_grouping_outcome %>% 
  mutate(match = case_when(group_rater1 == group_rater2 ~ 1L,
                           group_rater1 != group_rater2 ~ 0L,
                           is.na(group_rater1) | is.na(group_rater2) ~ 0L),
         group_final = NA_character_)
```

##### Counting the number of matches and non matches before discussion

```{r}
processed_grouping_outcome_match %>% 
  group_by(match) %>% 
  summarise(N = n()) %>% 
  mutate(sum_n = sum(N),
         freq = N / sum_n * 100)
```

##### Write matching rating results for discussion

```{r}
# write_xlsx(processed_grouping_outcome_match, "Processed/ReMis_Main_Processed_Grouping_Outcome_Match_data.xlsx")
```

### Prepare the final groups for further analysis

After discussing the non-match cases and coming to an agreement we read the final groups and prepare them for further analysis.

#### Data management mistake types
##### Read final groups

```{r}
processed_grouping_type_result_1 <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Type_Match_1_data.xlsx") %>% 
  mutate(mistake_no = as.integer(mistake_no))

processed_grouping_type_result_2 <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Type_Match_2_data.xlsx") %>% 
    mutate(mistake_no = as.integer(mistake_no))
```

##### Testing whether there was a change in the tables

```{r}
setdiff(
  select(processed_grouping_type_match_1, -group_final),
  select(processed_grouping_type_result_1, -group_final)
)

setdiff(
  select(processed_grouping_type_match_2, -group_final),
  select(processed_grouping_type_result_2, -group_final)
)
```

##### Transformation

```{r}
processed_grouping_type_result_1 <-
  processed_grouping_type_result_1 %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater1,
                                 TRUE ~ group_final),
         group_type = group_final) %>% 
  select(-group_final, -group_rater1, -group_rater2, -match)

processed_grouping_type_result_2 <-
  processed_grouping_type_result_2 %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater3,
                                 TRUE ~ group_final),
         group_type = group_final) %>% 
  select(-group_final, -group_rater3, -group_rater4, -match)

processed_grouping_type_result <-
  processed_grouping_type_result_1 %>% 
  bind_rows(., processed_grouping_type_result_2) %>% 
  mutate(type = mistake_type) %>% 
  select(-mistake_type)
```

```{r}
processed_grouping_type_result %>%
  
```

##### Count the number of responses that the raters could not assign to a group

```{r}
processed_grouping_type_result %>% 
  filter(group_type == "ambiguous") %>% 
  summarise(N = n()) %>% 
  mutate(freq = N / nrow(processed_grouping_type_result) * 100)
```

##### Saving the dataset

```{r}
# write_tsv(processed_grouping_type_result, "Processed/ReMis_Main_Processed_Type_Groups_data.tsv")
```

#### Causes of mistakes
##### Read final groups

```{r}
processed_grouping_cause_result <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Cause_Match_data.xlsx") %>% 
  mutate(cause_no = as.integer(cause_no))
```

##### Testing whether there was a change in the tables

```{r}
setdiff(
  select(processed_grouping_cause_match, -group_final),
  select(processed_grouping_cause_result, -group_final)
)
```

For the first cause (cause_no == 1) mentioned by the respondent (respondent_id == R_3lrEYOs4D0F0s0k) Rater 1 changed his or her decision of "bad or lack of standards" to "bad skill management" during the final discussion.

##### Transformation

```{r}
processed_grouping_cause_result <-
  processed_grouping_cause_result %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater1,
                                 TRUE ~ group_final),
         group_cause = group_final,
         type = cause_type) %>% 
  select(-group_final, -group_rater1, -group_rater2, -match, -cause_type)
```

##### Count the number of responses that the raters could not assign to a group

```{r}
processed_grouping_cause_result %>% 
  filter(group_cause == "ambiguous") %>% 
  summarise(N = n()) %>% 
  mutate(freq = N / nrow(processed_grouping_cause_result) * 100)
```

##### Saving the dataset

```{r}
# write_tsv(processed_grouping_cause_result, "Processed/ReMis_Main_Processed_Cause_Groups_data.tsv")
```

#### Outcomes of mistakes
##### Read final groups

```{r}
processed_grouping_outcome_result <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Outcome_Match_data.xlsx") %>% 
  mutate(outcome_no = as.integer(outcome_no))
```

##### Testing whether there was a change in the tables

```{r}
setdiff(
  select(processed_grouping_outcome_match, -group_final),
  select(processed_grouping_outcome_result, -group_final)
)
```

##### Transformation

```{r}
processed_grouping_outcome_result <-
  processed_grouping_outcome_result %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater1,
                                 TRUE ~ group_final),
         group_outcome = group_final,
         type = outcome_type) %>% 
  select(-group_final, -group_rater1, -group_rater2, -match, -outcome_type)
```

##### Count the number of responses that the raters could not assign to a group

```{r}
processed_grouping_outcome_result %>% 
  filter(group_outcome == "ambiguous") %>% 
  summarise(N = n()) %>% 
  mutate(freq = N / nrow(processed_grouping_outcome_result) * 100)
```

##### Saving the dataset

```{r}
# write_tsv(processed_grouping_outcome_result, "Processed/ReMis_Main_Processed_Outcome_Groups_data.tsv")
```

# This part is not cleaned yet:

# Grouping mistakes into data management stages

The groups that we used for the grouping of the **data management stages** were preregistered. Therefore, the groups were not created through coding and then sorting the codes into groups. However, during the grouping process we realized that the data management stages that we preregistered are not a good model of the research process of psychological research. Finaly, we decided not to include the result of the grouping in the manuscript but rather discuss our model for the data management stages of psychological research.

Nevertheless, the following code was used to prepare the data for grouping mistakes into data management stages.

## Exclusion

During the coding of the separated mistake responses for the mistake tpye grouping, the authors used codes to flag the cases that needs to be excluded from the mistake type and the mistake stage grouping as well.

```{r}
# Exclusion
processed_mistake_stage_filtered <-
  processed_mistake_type_coding %>% 
  filter(code %ni% c("irrelevant content",
                     "missing",
                     "out of timeframe",
                     "see above"))

# Saving datatabe after exclusion for further analysis
# write_tsv(processed_mistake_stage_filtered, "Processed/ReMis_Main_Mistake_Stage_Excluded_data.tsv")
```

## Sorting the responses to groups
### Creating spreadsheets for the raters

```{r}
# Rater1
## Transform data
processed_mistake_stage_rater1 <-
  processed_mistake_stage_filtered %>% 
  mutate(group_rater1 = NA_character_) %>% 
  slice(1:418)

## Write data
# write_xlsx(processed_mistake_stage_rater1, "Processed/rating/ReMis_Main_Processed_Stage_Rater1_data.xlsx")

# Rater2
## Transform data
processed_mistake_stage_rater2 <-
  processed_mistake_stage_filtered %>% 
  mutate(group_rater2 = NA_character_) %>% 
  slice(1:418)

## Write data
# write_xlsx(processed_mistake_stage_rater2, "Processed/rating/ReMis_Main_Processed_Stage_Rater2_data.xlsx")

# Rater3
## Transform data
processed_mistake_stage_rater3 <-
  processed_mistake_stage_filtered %>% 
  mutate(group_rater3 = NA_character_) %>% 
  slice(419:837)

## Write data
# write_xlsx(processed_mistake_stage_rater3, "Processed/rating/ReMis_Main_Processed_Stage_Rater3_data.xlsx")

# Rater4
## Transform data
processed_mistake_stage_rater4 <-
  processed_mistake_stage_filtered %>% 
  mutate(group_rater4 = NA_character_) %>% 
  slice(419:837)

## Write data
# write_xlsx(processed_mistake_stage_rater4, "Processed/rating/ReMis_Main_Processed_Stage_Rater4_data.xlsx")
```

### Validating the ratings
#### Read data

```{r}
## Rater 1
processed_grouping_stage_rater1 <-
  read_xlsx("Processed/rated/ReMis_Main_Processed_Stage_Rater1_data.xlsx")

## Rater 2
processed_grouping_stage_rater2 <-
  read_xlsx("Processed/rated/ReMis_Main_Processed_Stage_Rater2_data.xlsx")

## Rater 3
processed_grouping_stage_rater3 <-
  read_xlsx("Processed/rated/ReMis_Main_Processed_Stage_Rater3_data.xlsx")

## Rater 4
processed_grouping_stage_rater4 <-
  read_xlsx("Processed/rated/ReMis_Main_Processed_Stage_Rater4_data.xlsx")
```

#### Merging rated dataframes by corresponding raters

```{r}
processed_grouping_stage_1 <- 
  left_join(processed_grouping_stage_rater1, processed_grouping_stage_rater2, by = c("response_id", "mistake_type", "mistake", "mistake_no", "mistakes_sep"))

processed_grouping_stage_2 <- 
  left_join(processed_grouping_stage_rater3, processed_grouping_stage_rater4, by = c("response_id", "mistake_type", "mistake", "mistake_no", "mistakes_sep"))
```

#### Matching ratings

```{r}
processed_grouping_stage_match_1 <- 
  processed_grouping_stage_1 %>% 
  mutate(match = case_when(group_rater1 == group_rater2 ~ 1L,
                           group_rater1 != group_rater2 ~ 0L),
         group_final = NA_character_)

processed_grouping_stage_match_2 <- 
  processed_grouping_stage_2 %>% 
  mutate(match = case_when(group_rater3 == group_rater4 ~ 1L,
                           group_rater3 != group_rater4 ~ 0L),
         group_final = NA_character_)
```

#### Write matching rating results for discussion

```{r}
# write_xlsx(processed_grouping_stage_match_1, "Processed/ReMis_Main_Processed_Grouping_Stage_Match_1_data.xlsx")

# write_xlsx(processed_grouping_stage_match_2, "Processed/ReMis_Main_Processed_Grouping_Stage_Match_2_data.xlsx")
```

### Prepare the final groups for further analysis

#### Read final groups

```{r}
processed_grouping_stage_result_1 <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Stage_Match_1_data.xlsx")

processed_grouping_stage_result_2 <-
  read_xlsx("Processed/grouping/match/ReMis_Main_Processed_Grouping_Stage_Match_2_data.xlsx")
```

#### Transformation

```{r}
processed_grouping_stage_result_1 <-
  processed_grouping_stage_result_1 %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater1,
                                 TRUE ~ group_final),
         group_stage = group_final) %>% 
  select(-group_final, -group_rater1, -group_rater2, -match)

processed_grouping_stage_result_2 <-
  processed_grouping_stage_result_2 %>% 
  mutate(group_final = case_when(is.na(group_final) & match == 1L ~ group_rater3,
                                 TRUE ~ group_final),
         group_stage = group_final) %>% 
  select(-group_final, -group_rater3, -group_rater4, -match)

processed_grouping_stage_result <-
  processed_grouping_stage_result_1 %>% 
  bind_rows(., processed_grouping_stage_result_2) %>% 
  mutate(type = mistake_type) %>% 
  select(-mistake_type)
```

#### Saving the dataset

```{r}
# write_tsv(processed_grouping_stage_result, "Processed/ReMis_Main_Processed_Stage_Groups_data.tsv")
```

# Flowchart depicting the steps of the grouping process

```{r}
# See templates: https://github.com/aghaynes/misc/blob/master/flow_template.R
# https://rstudio-pubs-static.s3.amazonaws.com/90261_ad00e95221e14a33a50f2ebb56d34ab8.html
# https://davetang.org/muse/2017/03/31/creating-flowchart-using-r/

# Create the nodes
nodes <-
  create_node_df(
    n = 7,
    label = c("Responses",
              "Separated responses",
              "Grouping",
              "Ungrouped responses",
              "Grouped responses",
              "Codes",
              "Groups"),
    type = "lower",
    style = "filled",
    color = "grey",
    shape = rep("rectangle", 7)
  )

# Create edges
edges <-
  create_edge_df(
    from = c(1, 2, 2, 3, 3, 6),
    to = c(2, 3, 6, 4, 5, 7),
    rel = "related")

# Create the graph
flowchart <- create_graph(nodes_df = nodes,
                          edges_df = edges)

# See the graph
render_graph(flowchart)
```